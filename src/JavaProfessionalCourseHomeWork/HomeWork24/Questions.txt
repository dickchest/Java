## Уровень 1
1. Что такое `Pattern` и `Mathcer`?
это классы, которые предоставляют возможность работать с регулярными выражениями.
Pattern - описывает регулярное выражение. Matcher - осуществляет поиск в строке, с использованием рег. выражения, представленного обектом Pattern.

2. Как работает алгоритм поиска в `Matcher` жадно или лениво? Как можно добиться ленивого поиска?
Matcher работает жадно. Что бы он работал лениво, можно использовать квантификаторы, такие как *?, +? и ??, которые будут искать минимально возможное количество символов, удовлетворяющих регулярному выражению.
Также можно использовать символ ? после квантификаторов *, + и {}, чтобы сделать поиск ленивым.

3. Что содержит в себе `PatternSyntaxException`?
PatternSyntaxException - это исключение, которое возникает при ошибке синтаксиса в регулярном выражении, переданном в Pattern.compile() метод.
PatternSyntaxException содержит информацию о том, где произошла ошибка синтаксиса и какая именно ошибка была допущена. В частности, PatternSyntaxException содержит следующие поля:
- pattern - строка с регулярным выражением, в которой обнаружена ошибка синтаксиса.
- description - описание ошибки синтаксиса.
- index - индекс символа, на котором произошла ошибка синтаксиса.
- message - сообщение об ошибке.

4. Что означает `.` в регулярных выражениях? как сделать поиск по символу `.`? Как сделать поиск по `\`? когда применяется экранирование?
точка означает любой символ. чтобы сделать поиск по символу '.' нужно его эрканировать: \\. Также проивзодиться поиск по симовлу `\`.
Экранирование применяется в тех случаях, когда вы хотите использовать специальный символ (например, символ . или *) как обычный символ, а не как часть регулярного выражения. Для этого вы добавляете перед специальным символом обратную косую черту.

5. За что отвечают символы `*`, `+`, `?` `{3,5}`
Это квантификаторы, которые обозначают количество раз встречания предыдущего символа в искомом выражении.
* - предш. сиввол может повторяться от 0 до бесконечности раз
+ - один или больше раз
? - 0 или 1 раз.
{3,5} - от 3 до 5 раз

6. Как проверить совпадает ли вся строка указанному регулярному выражению?
нужно использовать метод matches() у обекта Matcher

7. Как исключить из поиска определенные символы?
Чтобы исключить из поиска определенные символы, можно использовать негативный символьный класс ([^...]) в регулярном выражении.

8. Как сделать именованную группу? `((A(B))(C))` что тут является группой 1, что группой 3? (посмотрите документацию [Pattern](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html), там есть объяснение похожего примера)
Именованная группа задается с помощью следующей синтаксической конструкции: (?<groupName>pattern)
1. ((A(B))(C))
2. (A(B))
3. (B)
4. (C)
в regex группы нумеруются по порядку следования открывающих скобок слева направо, начиная с 1.

9. В чем преимущество у `StringBuilder` vs `String`?
StringBuilder - позволяет строить стринг не создавая каждый раз новые переменные в String poole.

10. Считайте файл [результаты матчей](data/matches.txt)(из домашней работы 22) загрузите файл в строку(можно построчно считывать), и найдите в нем все названия команд, которые состоят из двух слов


11. Напишите программу, которая используя регулярные выражения будет проверять пароль на надежность:
                                - хотя бы 1 символ латинского алфавита в нижнем регистре
                                - хотя бы 1 символ латинского алфавита в верхнем регистре
                                - хотя бы 1 символ числа
                                - хотя бы 1 символ `!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`
                                - длина не меньше 8 символова в одну строку (используйте `StringBuilder`)

12. Заполните данные из файла в одну строку (используйте StringBuilder)

13. Есть строка `Carrot Collapse /\ Criteria, Avatar. Sort][Cabbage`, необходимо написать регулярное выражение, которое будет находить все слова начинающиеся на `C` и заканчивающийся на `t` или `e`

14. В строке `Carrot Collapse /\ Criteria, Avatar. Sort][Cabbage` нужно найти позиции небуквенных символов

14. Есть строка `01111000201010101701`. С помощью регулярного выражения проверьте является ли данная строка двиочным представлением (двичное счисло может содержать только 1 и 0), если есть ошибка верните индексы, где они встретились

## Уровень 2
1. Из файла с результатом матчей попробуйте создать регулярное выражение, которому соответствует каждая строка
2. Напишите проверку email на валидность мы не гонимся здесь за оригинальным стандартом (если интересно, то вот [стандарт](http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html)), наша задача сделать простую проерку
   - Имя email может содержать буквы и цифры латинского алфавита (максимум 30) и точку
   - После идет `@`
   - После может быть буквы, цифры и точка
   - После идет точка и от 2 до 4 символов
P.S. будьте внимательны с символом точка
3. Дан [файл](data/test-data.json). C посощью регулярных выражений найдите
   - Названия всех `boolean` переменных
   - Версию приложения (версия - любое число, находится в поле version)
   - Все поля (поле - строка, которая начинается с `{` и заканчивается `}`), в названии которых есть слово `normalizer`
4. Дан [файл](data/test-data.xml) (похоже на реальный пример данных, который отправляет сторонний сервис), с помощью регулярных выражений нужно получить:
   - Название всех типов(`sf:type`)
   - Id всех `PermissionSetAssignment`