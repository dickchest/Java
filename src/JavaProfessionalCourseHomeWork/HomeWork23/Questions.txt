## Уровень 1
1. C чем работает `InputStream` и `OutputStream`?
с битами. Существует для чтения и записи данных из/в различных источников/назначений

2. C чем работает `Reader` и `Writer`? когда лучше использовать `InputStream` а когда `Reader`?
Работают с символами. Инпут стрим лучше использовать, когда мы работаем с данными, обектами, т.е. не символьными данными. Ридер работает с симовлами и чарактерами.

3. Какой объект мы можем записать в файл с помощью `ObjectOutputStream`?
мы можем записать серилизованный обеъект. В частности, это могут быть объекты пользовательских классов, которые реализуют этот интерфейс.

4. Какое преимущество дает `BufferedInputStream`/`BufferedOutputStream`?
мы читаем сразу определенное количество байтов за раз и каждый раз не обращаемся к потоку, т.е. они уменьшают количество операций ввода/вывода и повышают производительность программы.

5. Почему необходимо вызывать метод `close()`?
Этот метод выполняет различные действия, которые зависят от типа потока, но общим для всех является освобождение системных ресурсов, которые были заняты этим потоком. Это включает закрытие файлов, сетевых соединений, баз данных и т.д.
Кроме того, если вы не закроете поток явно, то мы можем столкнуться с проблемами, такими как утечка ресурсов. Если мы не закроем поток, то ресурсы, связанные с этим потоком, могут оставаться занятыми в системе, даже после завершения работы программы. Это может привести к исчерпанию ресурсов и некорректной работе системы.
Если поток был открыт в блоке try с ресурсами, то он будет автоматически закрыт при выходе из блока try

6. Что такое try-with-resource? Почему предпочтительно использовать его при работе с ресурсами?
т.к. часто программисты забывают закрывать потоки.

7. Что делает mark/reset? Везде ли он есть?
Они предоставляют возможность пометить текущую позицию в потоке ввода и потом вернуться к ней позже.
Метод mark() устанавливает метку в текущую позицию в потоке. Мы можем затем считывать данные из потока, пока не достигнем предела, который мы хотим сохранить, и вызвать метод mark() для сохранения текущей позиции в потоке. Затем мы можем продолжить чтение потока и затем вернуться к сохраненной позиции, вызвав метод reset(). После вызова reset() поток ввода переходит в состояние, эквивалентное состоянию, в котором он находился в момент вызова mark(), и мы можем начать читать поток снова от этой позиции.

Методы mark() и reset() могут быть полезны, если нам нужно прочитать данные из потока несколько раз или если мы хотим вернуться к предыдущей позиции в потоке ввода.

Методы mark() и reset() доступны не во всех потоках ввода-вывода. Они предоставляются, например, в классах BufferedInputStream, ByteArrayInputStream, DataInputStream, FileInputStream, ObjectInputStream и т.д. Некоторые потоки ввода-вывода могут не поддерживать методы mark() и reset(), и попытка вызвать их может привести к выбросу исключения UnsupportedOperationException.

8. Можно ли преобразовать `InputStream` в `Reader`?
да можно. с помощью класса InputStreamReader


9. Напишите метод, который будет считывать с файла строку, подумайте что лучше использовать в этом случае (IS vs Reader)


10. Напишите метод, который будет записывать строку в файл, подумайте что лучше использовать в этом случае (OS vs Writer)

11. Напишите небольшую программу, которая будет работать с логикой игры, для этого создайте класс GameSaveResult(name, winCounter, loseCounter)
    - Программа в самом начале пытается посмотреть предыдущий результат в файле `result.txt`
      - если файла нет, то создает его и создает новый объект GameSaveResult с пустым каунтером и просит пользователя ввести имя с консоли
      - если файл существует, то считывает GameSaveResult из файла
    - дальше с помощью рандома генерируется результат `isWin`:
      - true - выигрыш
      - false - проигрыш
    - увеличивается нужный каунтер и сохраняется в этот же файл
    - запустите программу несколько раз

## Уровень 2
1. Возьмите файл из предыдущей домашки с результатами матчей, посчитайте сколько символов `,` встретилось в этом файле
2. Возьмите файл из предыдущей домашки и начните считывать его с 100 символа и считайте 200 символов, запишите это в отдельный файл
3. Считайте дынные из файла в массив байтов(считывайте с помощью read, который считывает не по одному элементу, а сразу пачку данных, распечатайте в консоль результат)
4. Создайте файл и запишите туда строку `Привет мир` с помощью `FileInputStream` и метода readAllBytes считайте все байты в массив байтов
   - возьмите `ByteArrayInputStream` и считайте все байты из массива, запишите результат в другой файл
5. посчитайте сколько раз каждая символ встречался в файле (используйте Map для хранения промежуточного результата), финальный результат запишите в файл