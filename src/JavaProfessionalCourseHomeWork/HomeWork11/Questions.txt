1. В чем разница Queue и Stack?
Stack (стек) - это структура данных (класс), работающая по принципу "Last-In, First-Out" (LIFO). Это означает, что последний добавленный элемент становится первым элементом, который будет удален. Добавление элемента в стек называется "push", а удаление элемента - "pop". Например, если в стек были добавлены элементы A, B и C в таком порядке, то при удалении элементов из стека, первым будет удален элемент C, затем B и в конце - A. Стек - потокобезопасен.
Queue (очередь) - это структура данных (интерфейс), работающая по принципу "First-In, First-Out" (FIFO). Это означает, что первый добавленный элемент будет первым, который будет удален. Добавление элемента в очередь также называется "enqueue", а удаление элемента - "dequeue". Например, если в очередь были добавлены элементы A, B и C в таком порядке, то при удалении элементов из очереди, первым будет удален элемент A, затем B и в конце - C. Имеет не потокобезопасные интерфейсы ArrayDeque & LinkedList

2. Чем можно заменить Stack?
Deque - двусторонняя очередь - предоставляет функциональность стека и очереди одновременно.

3. Какие реализации Dequeue есть?
ArrayDeque, LinkedList

4. Что находится под капотом ArrayDequeue? как решается проблема с добавлением в начало массива?
массив зацикливается и добавление происходит по факту в конец массива (при значении head = 0)

5. Что используется для выставления приоритета в PriorityQueue?
Comparator или естественый порядок

6. Что такое маркерные интерфейсы? какие знаете?
Маркерный интерфейс (marker interface) - это интерфейс, который не содержит методов, но служит для пометки (отметки) класса, который реализует этот интерфейс. Маркерный интерфейс определяет некоторую метаинформацию о классе, которая может использоваться в дальнейшем при разработке программного обеспечения.
Как правило, маркерные интерфейсы используются для реализации определенной функциональности в классе или для указания классу, как его использовать.
Serializable - это маркерный интерфейс, который говорит JVM, что объект этого класса может быть сериализован.
Cloneable - маркерный интерфейс, который говорит JVM, что объект класса может быть клонирован с помощью метода clone().
Remote - маркерный интерфейс, который говорит, что объект класса может быть удаленно вызван в распределенной системе.
SingleThreadModel - маркерный интерфейс, который говорит, что объект класса может быть безопасно использован в многопоточной среде, но только в одном потоке.
RandomAccess - это маркерный интерфейс в Java, который используется для обозначения того, что список (или другая коллекция) имеет быстрый произвольный доступ к своим элементам.

7. Есть массив из Integer, но там произошло дублирование одного из чисел, нужно найти на какой позиции и значение элемента которое задублировалось Подсказка: add у Set возвращает boolean, посмотрите в документации когда он возвращает true, когда false, это можно использовать для нахождения дубликата

8. Создайте экземпляры Stack, Deque (LinkedList), Deque (ArrayDeque), добавьте туда 1 млн строк (метод push), после достаньте элементы пока есть элементы(метод pool), сделайте замер времени для добавления и для доставания, напишите в отдельный файл результат вычисления и постарайтесь дать объяснение почему что-то отработало быстрее

Adding: Stack
46
Adding: LinkedList
139
Adding: ArrayDeque
75
-----------------
Pop: Stack
58
Pop: LinkedList
19
Pop: ArrayDeque
14

Быстрое добавление в стек обусловлено тем, что нет необходимсоти постоянно изменять массив и реорганизовывать его.
Доставание из стека наоборот ведет к удалению элемента из массива с последующей его реорганизацией.
В линклисте и аррайдекью извлечение из конца списка является более эффективной операцией, поскольку не требуется перезапись массива.


9. Есть клиенты мобильного оператора, каждый клиент содержит поле isVip у нас 10 клиентов они встают в очередь, очередь с приоритетом (вип клиенты обслуживаются раньше чем другие клиенты)
[Client 1 {false}
, Client 4 {false}
, Client 3 {false}
, Client 9 {false}
, Client 10 {false}
, Client 6 {true}
, Client 7 {false}
, Client 8 {true}
, Client 2 {true}
, Client 5 {true}
]
Не понимаю, почему не работает с клиентом 6 и 7.