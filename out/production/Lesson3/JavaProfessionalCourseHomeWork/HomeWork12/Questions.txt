Уровень 1

1. Что такое Copy и DeepCopy?
Копирование (Copy) - это процесс создания нового объекта, который имеет те же значения полей, что и исходный объект. Однако, если объект содержит ссылки на другие объекты, то при копировании создается только новая ссылка на тот же объект, а не создается новый объект. Простым способом создания копии объекта является использование конструктора копирования или метода клонирования.

Глубокое копирование (DeepCopy) - это процесс создания нового объекта, который имеет те же значения полей, что и исходный объект, но при этом создаются новые объекты для всех объектов, на которые ссылается исходный объект. Это означает, что изменения в объектах, на которые ссылается исходный объект, не будут отражаться в новом объекте. Глубокое копирование может быть достигнуто путем рекурсивного прохода по всем полям объекта и создания копий всех объектов, на которые есть ссылки.

2. Что такое хэш-код?
Хэш-код (Hash code) - это целочисленное значение, которое ассоциируется с объектом. Хэш-код вычисляется с помощью функции хэширования, которая преобразует произвольные данные в числа определенного диапазона.
В Java каждый объект имеет метод hashCode(), который возвращает хэш-код этого объекта. Если класс не переопределяет метод hashCode(), то по умолчанию он возвращает уникальный идентификатор объекта в памяти (адрес объекта).

3. Что такое коллизия? какие способы решения есть
Коллизия (Collision) - это ситуация, когда два или более объекта имеют одинаковый хэш-код, но не являются равными в смысле метода equals(). Такая ситуация может возникнуть в результате вычисления хэш-кодов для разных объектов с использованием одного и того же алгоритма хэширования, который имеет ограниченный диапазон возможных значений.
Способы решения проблемы коллизий:
- Раздельная цепь (Separate Chaining) - реализовать массив в виде списка,
называемого цепью.
- Открытая адресация (Open Addressing) - используем следующий пустой слот в
самой хэш-таблице.

4. Коротко опишите устройство HashMap
HashMap в Java - это реализация ассоциативного массива, который использует хеш-таблицу для хранения пар ключ-значение. Он позволяет быстро добавлять, удалять и искать элементы по ключу.
Устройство HashMap состоит из массива ячеек (bucket), каждая из которых содержит связанный список элементов (Node). При добавлении элемента в HashMap, вычисляется его хэш-код и на основе этого значения определяется индекс ячейки, в которую будет помещен элемент. Если в ячейке уже есть элементы, то они хранятся в связанном списке, а новый элемент добавляется в конец списка.

5. Дана строка, вывести количество появлений каждого символа в этой строке. Вместо char в мапе используйте обертку Character Например: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer eu feugiat tellus. Nam molestie diam sed libero egestas pellentesque. Nulla.

Символ e встречается 20 раз.
Символ пробел/space встречается 19 раз.
Символ l встречается 11 раз.
Символ i встречается 11 раз.
Символ t встречается 11 раз.
Символ s встречается 10 раз.
Символ u встречается 7 раз.
Символ a встречается 7 раз.
Символ n встречается 6 раз.
Символ m встречается 6 раз.
Символ o встречается 6 раз.
Символ r встречается 5 раз.
Символ . встречается 4 раз.
Символ g встречается 4 раз.
Символ d встречается 4 раз.
Символ c встречается 3 раз.
Символ p встречается 3 раз.
Символ , встречается 1 раз.
Символ f встречается 1 раз.
Символ b встречается 1 раз.
Символ q встречается 1 раз.

6. Однажды Вася решил посмотреть результаты финала чемпионата Берляндии по футболу 1910 года. К сожалению, он не нашел итоговый счет матча, зато нашел подробное текстовое описание хода всей игры. Всего в этом описании оказалось n строк, каждая из которых описывала один гол. Каждый гол обозначался названием забившей его команды. Помогите Васе — узнайте название команды, победившей в финале. Гарантируется, что матч не закончился вничью.

7. Дан лист из 1000 чисел (заполните его рандомом), необходимо найти дубликаты


Уровень 2

1. Напишите логику для регистрации пользователя для этого
- создайте класс UserService, который имеет метод signUp(...), который принимает логин и пароль и создает объект User и сохраняет его в хеш мапу, если пользователь уже существует возвращайте null
- подумайте что делать с паролем пользователя, так как он должен храниться в зашифрованном виде
- так же сервис должен проверять что пароль надежный (хотя бы 1 большая буква, 1 маленькая, длина больше 8 и содержит один из символов !@#$%^&*()_+)
- создайте метод signIn(login, password) - который производит логин пользователя, если он существует и если пароль пользователя совпадает(может быть коллизия но не берите в счет этого на данном этапе)

2. Дан лист из 1000 чисел (заполните его от 1 до 1000 и размешайте его - запустите метод Collections.shufle(..)), необходимо найти пары чисел которые в сумме дают число k (сгенерируйте рандомом) Рандомом генерируйте числа от 0 до 1000